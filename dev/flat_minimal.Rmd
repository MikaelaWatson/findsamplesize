---
title: "flat_minimal.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)

# Sample size calculation  Zhou et al
sample_size_calculation <- function(sensitivity, alpha, power, margin, prevalence = NULL, prevalence_power = NULL){
  alpha_val         <- 1-alpha/2
  
  sample_size <- ((qnorm(alpha_val) + qnorm(power)) * sqrt(sensitivity*(1-sensitivity)))^2 / margin^2
  
  if(!is.null(prevalence)){
    a           <- prevalence^2
    c           <- sample_size^2
    b           <- -(2 * sample_size * prevalence + qnorm(prevalence_power)^2 * prevalence * (1 - prevalence))
    delta       <- b^2 - 4 * a * c
    sample_size <- (-b + sqrt(delta)) / (2*a)
  }
}



n_tot_calculation <-function(prevalence, sample_size, prevalence_power){
     a           <- prevalence^2
    c           <- sample_size^2
    b           <- -(2 * sample_size * prevalence + qnorm(prevalence_power)^2 * prevalence * (1 - prevalence))
    delta       <- b^2 - 4 * a * c
    sample_size <- (-b + sqrt(delta)) / (2*a)
    return(sample_size)
}

 power_calc <- function(sample_size, margin, sensitivity, alpha) {
   alpha_val         <- 1-alpha/2
   (sqrt(sample_size * margin^2) / (sqrt(sensitivity*(1-sensitivity)))) - qnorm(alpha_val) -> qp
   power <- pnorm(qp)
   return(power)
 }
 
 
 margin_calc <- function(alpha, power, sensitivity, sample_size) {
   alpha_val         <- 1-alpha/2
   margin <- sqrt((((qnorm(alpha_val) + qnorm(power)) * sqrt(sensitivity*(1-sensitivity)))^2)/sample_size)
   return(margin)
 }
 
 
 sample_size_calculation(sensitivity= 0.8, alpha=0.05, power=0.8, margin=0.1, prevalence = NULL, prevalence_power = NULL)
sample_size_calculation(sensitivity= 0.97, alpha=0.05, power=0.8, margin=0.05, prevalence = NULL, prevalence_power = NULL)
n_tot_calculation(prevalence = 0.05, sample_size=60, prevalence_power=0.8)

n_tot_calculation(prevalence = 0.1, sample_size=60, prevalence_power=0.8)
n_tot_calculation(prevalence = 0.2, sample_size=60, prevalence_power=0.8)

power_calc(sample_size = 60, margin=0.15, sensitivity=0.8, alpha=0.05)
power_calc(sample_size = 200, margin=0., sensitivity=0.97, alpha=0.05)

margin_calc(0.05, 0.8, 0.8, 60)


```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.
-->

### Sample size calculation  
Calculates the  sample size to estimate the accuracy of a single diagnostic test, and generates a power table based on Zhou et al.
Calculates sample size in terms of true positives/ true negatives based on the parameters entered.
When prevalence and prevalence power are not entered the function gives the number of true positives/negatives. When they are entered, it gives the total number of subjects to be screened.

```{r function-sample_size_calculation}
#' sample_size_calculation
#'
#' @param sen_spe numeric, sensitivity/specificity
#' @param alpha numeric, significance level
#' @param power numeric, desired power
#' @param margin numeric, the error margin
#' @param prevalence numeric, prevalence of the disease. For specificity put 1-diesease prevalance
#' @param prevalence_power numeric, the power to detect the prevalence
#' @param performance_characteristic character, "sen" for sensitivity, "spe" for specificity
#'
#' @return sample size 
#' 
#' @references Zhou XH, Obuchowski NA and McClish DK. Statistical Methods in Diagnostic Medicine. 2011;2:193-228
#' @export
#'
#' @examples
sample_size_calculation <- function(sen_spe, alpha, power, margin, prevalence = NULL, prevalence_power = NULL, performance_characteristic = "sen") {
  alpha_val         <- 1-alpha/2
  
  sample_size <- ((qnorm(alpha_val) + qnorm(power)) * sqrt(sen_spe*(1-sen_spe)))^2 / margin^2


  
  if(!is.null(prevalence)){
      if(performance_characteristic == "spe"){
    prevalence <- 1-prevalence
  }
    a           <- prevalence^2
    c           <- sample_size^2
    b           <- -(2 * sample_size * prevalence + qnorm(prevalence_power)^2 * prevalence * (1 - prevalence))
    delta       <- b^2 - 4 * a * c
    sample_size <- (-b + sqrt(delta)) / (2*a)
  }
  return(ceiling(sample_size))
}

```


```{r examples-sample_size_calculation}
 sample_size_calculation(sen_spe= 0.8, alpha=0.05, power=0.8, margin=0.05, prevalence = NULL, prevalence_power = NULL, performance_characteristic = "sen") 
# Number of true positives for a sensitivity of 80%

 sample_size_calculation(sen_spe= 0.8, alpha=0.05, power=0.8, margin=0.05, prevalence = 0.1, prevalence_power = 0.9, performance_characteristic = "sen") 
 # Total  number of patients to be screened to test 80% sensitivity with 10% prevalence and 80% prevalence power


```

```{r tests-sample_size_calculation}
test_that("sample_size_calculation works", {
  expect_equal(sample_size_calculation(sen_spe= 0.8, alpha=0.05, power=0.8, margin=0.05, prevalence = NULL, prevalence_power = NULL, performance_characteristic = "sen"), 503)
})
```

### Total N Calculation: 
 Calculates the total number of subjects to be screened to estimate the accuracy of a single diagnostic test, based on a known number of true positives/negatives that is needed, an estimate of prevalence , and prevalence power.

```{r function-n_tot_calculation}
#' Total N Calculation
#' 
#' 
#' @param prevalence Disease prevalence
#' @param sample_size Number of positives needed
#' @param prevalence_power the power to detect the prevalence
#' 
#' #'
#' @return total number of subjects to be screened 
#' @export
#' 
#' @references Zhou XH, Obuchowski NA and McClish DK. Statistical Methods in Diagnostic Medicine. 2011;2:193-228
#'
#' @examples
n_tot_calculation <-function(prevalence, sample_size, prevalence_power){
     a           <- prevalence^2
    c           <- sample_size^2
    b           <- -(2 * sample_size * prevalence + qnorm(prevalence_power)^2 * prevalence * (1 - prevalence))
    delta       <- b^2 - 4 * a * c
    N <- (-b + sqrt(delta)) / (2*a)
    return(ceiling(N))
}
```

```{r examples-n_tot_calculation}

 n_tot_calculation(sample_size=503, prevalence = 0.1, prevalence_power = 0.9) 
# Total  number of patients to be screened to test 80% sensitivity with 10% prevalence and 80% prevalence power. 
# Should give the same number as the second example of sample_size_calculation

```

```{r tests-n_tot_calculation}
test_that("n_tot_calculation works", {
  expect_equal(n_tot_calculation(sample_size=503, prevalence = 0.1, prevalence_power = 0.9 ), 5311)
})
```


### Error margin Calculation  

Calculates the margin of error for one side based on the significance, power, sensitivity/specificity, and the number true positives/negatives, to estimate the accuracy of a single diagnostic test.



```{r function-margin_calc}

#' Error Margin Calculation
#'
#' @param alpha numeric, significance level
#' @param power numeric, desired power
#' @param sen_spe numeric, sensitivity/specificity of a test
#' @param sample_size numeric, number of true positives/negatives to be screened
#'
#' @return numeric, error margin on one side of the confidence interval
#' @references Zhou XH, Obuchowski NA and McClish DK. Statistical Methods in Diagnostic Medicine. 2011;2:193-228
#' 
#' @export
#'
#' @examples
 margin_calc <- function(alpha, power, sen_spe, sample_size) {
   alpha_val         <- 1-alpha/2
   margin <- sqrt((((qnorm(alpha_val) + qnorm(power)) * sqrt(sen_spe*(1-sen_spe)))^2)/sample_size)
   return(round(margin, digits=2))
 }
 
```


```{r examples-margin_calc}

 margin_calc(alpha=0.05, power=0.8, sen_spe=0.8, sample_size=502) 
# Error margin on one side. Using the same parameters as sample_size_calculation. Should be ~0.05

```

```{r tests-margin_calc}
test_that("margin_calc works", {
  expect_equal(margin_calc(alpha=0.05, power=0.8, sen_spe=0.8, sample_size=502), 0.05)
})
```


### Calculate Power  

Calculate the power of the design based on sample size, error margin, sensitivity/specificity and significance level, for the estimation of the accuracy of a single diagnostic test.

```{r function-power_calc}
#' Power Calculation
#'
#' @param sample_size numeric, confirmed positives/negatives
#' @param margin numeric, the error margin
#' @param sen_spe test performance characteristice estimate
#' @param alpha significance level
#'
#' @return
#' @export
#' @references Zhou XH, Obuchowski NA and McClish DK. Statistical Methods in Diagnostic Medicine. 2011;2:193-228
#' 
#' @examples
 power_calc <- function(sample_size, margin, sen_spe, alpha) {
   alpha_val         <- 1-alpha/2
   (sqrt(sample_size * margin^2) / (sqrt(sen_spe*(1-sen_spe)))) - qnorm(alpha_val) -> qp
   power <- pnorm(qp)
   return(round(power, digits = 2))
 }
 
```


```{r examples-power_calc}

 power_calc(alpha=0.05, margin=0.05, sen_spe=0.8, sample_size=502) 
# Power of the study. Using the same parameters as sample_size_calculation. Should be ~80%

```

```{r tests-power_calc}
test_that("power_calc works", {
  expect_equal(power_calc(alpha=0.05, margin=0.05, sen_spe=0.8, sample_size=502), 0.8)
})
```


### Sample Size Population Proportion 

Calculate the sample size necessary to estimate a proportion in a finite or infinite proportion. (Daniel et. al)


```{r function-sample_size_pop_prop}

#' Sample Size Population Proportion
#'
#' @param alpha numeric, significance level
#' @param p   numeric, estimated proportion
#' @param margin numeric, error margin
#' @param N numeric, population size
#'
#' @return
#' @export
#'
#' @references Daniel  WW  (1999).  Biostatistics:  A  Foundation for   Analysis   in   the   Health   Sciences.   7th edition. New York: John Wiley & Sons.
#'
#' @examples
n_pop_prop <- function(alpha, p, margin, N=NULL) {
  alpha_val         <- 1-alpha/2
  X <- qnorm(alpha_val)^2 * p * (1-p) / margin^2
  if (is.null(N)){
      n = X
  } else {
      n = N*X / (X + N-1)
  }
  return(ceiling(n))
}

```

```{r examples-sample_size_pop_prop}

 n_pop_prop(alpha = 0.05, p =  0.5, margin = 0.1, N = 1000) 

# sample size for a population of 1000 people to estimate that at least half of the population has the desired characteristic with an error margin of 10%

 n_pop_prop(alpha = 0.05, p =  0.5, margin = 0.1) 
 # same calculation in an infinite population
```

```{r tests-n-n_por_prop}
test_that("n_por_prop works", {
   expect_equal(n_pop_prop(alpha = 0.05, p =  0.5, margin = 0.1), 97)
    expect_equal(n_pop_prop(alpha = 0.05, p =  0.5, margin = 0.1, N=100), 50)
})
```


### cluster_random_sample_size

Calculates the number of clusters necessary for a cluster randomized trials. 
    
```{r function-cluster_random_sample_size}
#' Cluster Random Sample Size
#' 
#' Gives the number of (pairs when available) of clusters required for  cluster randomized trials
#' 
#' @param alpha significance levels
#' @param power the desired power
#' @param coef_var between-cluster variation, use 0.25 if unknown as this is the estimated maximum
#' @param A Adjustment for loss of degrees of freedom (1 for unpaired trials, 2 in paired trials)
#' @param pi proportion in the intervention group
#' @param pc proportion in the control group
#' @param CS an estimate of cluster size
#'
#' @return number of clusters required in each treatment group in an unmatched design, and total pairs in a paired design.
#' @references Hayes, R. J., & Moulton, L. H. (2017). Cluster randomised trials. Chapman and Hall/CRC.
#' 
#' @export
cluster_random_sample_size <- function(alpha, power, coef_var=0.25, A=2, pi, pc, CS){
  alpha_val <- 1-alpha/2
  qq <- ( qnorm(alpha_val) +qnorm(power))^2
  i <- pi*(1-pi)/CS
  c <- pc*(1-pc)/CS
  s <- (coef_var^2)*(pi^2 + pc^2)
  f <-(i+c+s)/((pi-pc)^2)
  N <- A + qq*f
  return(ceiling(N))

}
```
  
```{r example-cluster_random_sample_size}

# The matched trial protocol required 80% power of detecting a 50% reduction of annual HIV incidence from an assumed 1% in the control arm (π0 = 0.02 over 2 years) to 0.5% in the intervention arm (π1 = 0.01). Thus, with m = 1000 adults followed up in each cluster, the number of clusters required per treatment arm in a matched design was gives 6.8 = 7 cluster pairs
cluster_random_sample_size(alpha=0.05, power=0.8, coef_var=0.25, A =2, pi=0.01, pc=0.02, CS=1000)
```
  
```{r tests-cluster_random_sample_size}
# Innpaired design - the number of clusters required for each treatment group
# incidence of a disease in control group: 0.0148
# incidence in intervention group: 0.0104
# desired power: 0.8
# significance : 0.05
# people per cluster : 424
# variation in clusters: 0.29
test_that("cluster_random_sample_size works", {
  expect_equal(cluster_random_sample_size(alpha = 0.05, power =0.8, coef_var = 0.29, A =1, pi =0.0104, pc = 0.0148, CS = 424), 36)
})
```
  


```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_minimal.Rmd", vignette_name = "Sample Size Calculations", overwrite = TRUE)
```
